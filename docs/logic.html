<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>spatial.logic API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spatial.logic</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import pickle
import warnings
from typing import Dict

import numpy as np
from lark import Lark, Transformer, Tree, v_args
from lark.tree import pydot__tree_to_graph
from lark.visitors import Interpreter

from spatial.geometry import SpatialInterface, ObjectInTime


@v_args(inline=True)  # Affects the signatures of the methods
class SpatRelInterpreter(Transformer):
    &#34;&#34;&#34;
    Interpreter for spatial relations. Delegates parsed tree to corresponding operations.
    &#34;&#34;&#34;

    # from operator import neg, and_ as b_and, or_ as b_or
    # from operator import and_, or_, not_
    number = float

    def __init__(self):
        &#34;&#34;&#34;
        Initializes the interpreter
        &#34;&#34;&#34;
        super().__init__()
        self.vars: Dict[str, ObjectInTime] = {}
        self.number_vars: Dict[str, float] = {}
        self._global_time = 0

    def set_global_time(self, time: int):
        assert time &gt;= 0, &#34;&lt;Interpreter&gt;: global time must be non-negative! Got: {}&#34;.format(time)
        self._global_time = time

    @staticmethod
    def spatial(a):
        &#34;&#34;&#34;
        Maps quantitative semantics to bool domain
        Args:
            a: The float value

        Returns: True if val&gt;=0 and False otherwise

        &#34;&#34;&#34;
        return a

    @staticmethod
    def and_(a, b) -&gt; float:
        &#34;&#34;&#34;
        Computes the quantitative semantics of AND operator
        Args:
            a: predicate left of operator
            b: predicate right of operator

        Returns: min(a,b)

        &#34;&#34;&#34;
        return np.min([a, b])

    @staticmethod
    def or_(a, b) -&gt; float:
        &#34;&#34;&#34;
        Computes the quantitative semantics of OR operator
        Args:
            a: predicate left of operator
            b: predicate right of operator

        Returns: max(a,b)

        &#34;&#34;&#34;
        return np.max([a, b])

    @staticmethod
    def xor_(a, b) -&gt; float:
        &#34;&#34;&#34;
        Computes the quantitative semantics of XOR operator
        Args:
            a: predicate left of operator
            b: predicate right of operator

        Returns: max(a,b)

        &#34;&#34;&#34;
        # a XOR b = (a &amp; !b) | (!a &amp; b)
        a_notb = np.min([a, -b])
        nota_b = np.min([-a, b])
        return np.max([a_notb, nota_b])

    @staticmethod
    def implies_(a, b) -&gt; float:
        &#34;&#34;&#34;
        Computes the quantitative semantics of IMPLIES operator
        Args:
            a: predicate left of operator
            b: predicate right of operator

        Returns: max(a,b)

        &#34;&#34;&#34;
        # a -&gt; b = !a | b
        return np.max([-a, b])

    @staticmethod
    def not_(a) -&gt; float:
        &#34;&#34;&#34;
        Computes the quantitative semantics of not operator
        Args:
            a: predicate to negate

        Returns: -a

        &#34;&#34;&#34;
        return -a

    @property
    def vars(self) -&gt; dict:
        &#34;&#34;&#34;
        Dictionary of stored (name, variable) pairs
        Returns: dictionary

        &#34;&#34;&#34;
        return self._vars

    @vars.setter
    def vars(self, vars: dict):
        &#34;&#34;&#34;
        Sets the dictionary of stored (name, variable) pairs
        Args:
            vars: Dictionary

        &#34;&#34;&#34;
        if len(vars) &gt; 1:
            elements = list(vars.values())
            assert all([isinstance(k, type(elements[0])) for k in
                        elements]), &#39;&lt;SpatialInterpreter&gt;: only one type of obstacle currently supported!&#39;
        self._vars = vars

    @property
    def number_vars(self) -&gt; dict:
        &#34;&#34;&#34;
        Returns the dictionary of stored (name, numerical variable) pairs
        Returns: dictionary

        &#34;&#34;&#34;
        return self._number_vars

    @number_vars.setter
    def number_vars(self, number_vars: dict):
        &#34;&#34;&#34;
        Sets the dictionary of stored (name, numerical variable) pairs
        Args:
            number_vars: dictionary

        &#34;&#34;&#34;
        assert len(number_vars) == 0 or all([isinstance(k, (float, int)) for k in
                                             [number_vars.values()]]), &#39;&lt;SpatialInterpreter&gt;: only numbers supported!&#39;
        self._number_vars = number_vars

    def assign_var(self, name: str, value: ObjectInTime):
        &#34;&#34;&#34;
        Assigns a new variable to the interpreter
        Args:
            name: Name of the variable
            value: Value of the variables (spatial interface object or int/float)

        &#34;&#34;&#34;

        assert isinstance(name, str), &#39;&lt;Logic&gt;: name must be of type string! Got {}&#39;.format(name)

        if isinstance(value, (int, float)):
            self.number_vars[name.lower()] = value
        else:

            assert isinstance(value, ObjectInTime), &#39;&lt;Logic&gt;: value must be of type &#39; \
                                                    &#39;ObjectInTime! Got {}&#39;.format(
                value)

            self.vars[name.lower()] = value
        return value

    def var(self, name: str) -&gt; SpatialInterface:
        &#34;&#34;&#34;
        Returns the variable corresponding to the provided name
        Args:
            name: Name of the variable

        Returns: spatial interface object of name

        &#34;&#34;&#34;

        # query latest time step
        return self.var_at(name, 0)

    def var_at(self, name: str, rel_time: int) -&gt; SpatialInterface:
        &#34;&#34;&#34;
        Returns the variable corresponding to the provided name and time step
        Args:
            name: Name of the variable
            rel_time: relative time identifier

        Returns: spatial interface object of name

        &#34;&#34;&#34;

        assert rel_time &gt;= 0., &#39;&#39;

        try:
            obj: ObjectInTime = self.vars[name.lower()]
        except KeyError:
            raise Exception(&#34;Variable not found: %s&#34; % name)

        try:
            return obj.getObject(self._global_time - rel_time)
        except Exception:
            raise Exception(&#34;Time step index t={} not found&#34;.format(self._global_time - rel_time))

    @staticmethod
    def enlarge(o: SpatialInterface, radius: float):
        return o.enlarge(radius)

    def numeric_var(self, name):
        &#34;&#34;&#34;
        Returns the numeric variable of a specified name
        Args:
            name: The specified name

        Returns: int/float object corresponding to specified name

        &#34;&#34;&#34;
        try:
            return self.number_vars[name.lower()]
        except KeyError:
            raise Exception(&#34;Variable not found: %s&#34; % name)

    @staticmethod
    def left_of(left: SpatialInterface, right: SpatialInterface):
        return left.left_of(right)

    @staticmethod
    def right_of(left: SpatialInterface, right: SpatialInterface):
        return left.right_of(right)

    @staticmethod
    def below_of(left: SpatialInterface, right: SpatialInterface):
        return left.below(right)

    @staticmethod
    def above_of(left: SpatialInterface, right: SpatialInterface):
        return left.above(right)

    @staticmethod
    def overlap(left: SpatialInterface, right: SpatialInterface):
        return left.overlap(right)

    @staticmethod
    def touching(left: SpatialInterface, right: SpatialInterface):
        return left.touching(right)

    @staticmethod
    def far_from(left: SpatialInterface, right: SpatialInterface):
        return left.far_from(right)

    @staticmethod
    def close_to(left: SpatialInterface, right: SpatialInterface):
        return left.close_to(right)

    @staticmethod
    def enclosed_in(left: SpatialInterface, right: SpatialInterface):
        return left.enclosed_in(right)

    @staticmethod
    def comparison(left: SpatialInterface, right: SpatialInterface):
        return [left, right]

    @staticmethod
    def moved(left: SpatialInterface, right: SpatialInterface):
        val = left.enclosed_in(right.enlarge(25))
        return val if np.isclose(val, 0) else -val

    @staticmethod
    def operator(value):
        &#34;&#34;&#34;
        Maps operators (&lt;=,&gt;=,=) to numpy functions
        Args:
            value: The operator to map

        Returns: Numpy functions object

        &#34;&#34;&#34;
        # &#34;&lt;=&#34; | &#34;&gt;=&#34; | &#34;==&#34;
        if value == &#34;&lt;=&#34;:
            return np.less_equal
        if value == &#34;&gt;=&#34;:
            return np.greater_equal
        if value == &#34;==&#34;:
            return np.equal

    @staticmethod
    def closer_to(left: SpatialInterface, right: list):
        return left.closer_to_than(right[0], right[1])

    @staticmethod
    def distance(left: SpatialInterface, right: SpatialInterface, fun, eps):
        return left.distance_compare(right, eps, fun)


# custom function wrapper for the SpatialInterpreter.visit() function
def _vargs_tree_time(f, data, children, meta, lower, upper):
    return f(Tree(data, children, meta), lower, upper)


@v_args(wrapper=_vargs_tree_time)
class SpatialInterpreter(Interpreter):
    &#34;&#34;&#34;
    Interpreter object for the temporal parts of Spatial. Delegates parsed tree to corresponding operations.
    &#34;&#34;&#34;

    def __init__(self, spatial, quantitative: bool = False):
        self._quantitative = quantitative
        self._spatial_interpreter = spatial
        self._spatial_dict = {}
        self.vars = {}

    @property
    def quantitative(self) -&gt; bool:
        &#34;&#34;&#34;
        Bool whether this interpreter returns boolean or quantitative values

        Returns: True if quantitative

        &#34;&#34;&#34;
        return self._quantitative

    @quantitative.setter
    def quantitative(self, quantitative: bool):
        &#34;&#34;&#34;
        Bool whether this interpreter returns boolean or quantitative values
        Args:
            quantitative: Set a new bool

        &#34;&#34;&#34;
        self._quantitative = quantitative

    @property
    def vars(self) -&gt; dict:
        &#34;&#34;&#34;
        Dictionary of stored (name, variable) pairs
        Returns: dictionary

        &#34;&#34;&#34;
        return self._vars

    @vars.setter
    def vars(self, vars: dict):
        &#34;&#34;&#34;
        Sets the dictionary of stored (name, variable) pairs
        Args:
            vars: Dictionary

        &#34;&#34;&#34;
        if len(vars) &gt; 1:
            elements = list(vars.values())
            assert all([isinstance(k, ObjectInTime) for k in
                        elements]), &#39;&lt;SpatialInterpreter&gt;: only ObjectInTime currently supported!&#39;
        self._vars = vars

    def assign_var(self, name: str, value: ObjectInTime):
        &#34;&#34;&#34;
        Assigns a new variable to the interpreter
        Args:
            name: Name of the variable
            value: Value of the variables (ObjectInTime interface object or int/float)

        &#34;&#34;&#34;
        if isinstance(value, (int, float)):
            self._spatial_interpreter.assign_var(name, value)
        else:

            assert isinstance(value,
                              ObjectInTime), &#39;&lt;SpatialInterpreter&gt;: value must be of type &#39; \
                                             &#39;ObjectInTime or int/float! Got {}&#39;.format(
                value)
            assert isinstance(name, str), &#39;&lt;SpatialInterpreter&gt;: name must be of type string! Got {}&#39;.format(name)

            self.vars[name.lower()] = value
        return value

    def var(self, name: str) -&gt; ObjectInTime:
        &#34;&#34;&#34;
        Returns the variable corresponding to the provided name
        Args:
            name: Name of the variable

        Returns: spatial interface object of name

        &#34;&#34;&#34;
        try:
            return self.vars[name.lower()]
        except KeyError:
            raise Exception(&#34;Variable not found: %s&#34; % name)

    # translates the relative bounds of bounded temporal operators into the absolute time
    @staticmethod
    def relative_to_absolute_bounds(rel_lower, rel_upper, lower, upper):
        assert rel_lower &gt;= 0 and rel_upper &gt;= 0, \
            &#39;&lt;SpatialInterpreter&gt;: negative bounds in bounded temporal operators not allowed!&#39;
        assert rel_lower &lt;= rel_upper, \
            &#39;&lt;SpatialInterpreter&gt;: relative lower bound is higher than relative upper bound&#39;

        abs_lower = lower + rel_lower
        abs_upper = min(upper, lower + rel_upper)

        return abs_lower, abs_upper

    # hacky override of original function. provides necessary extra parameters for custom function wrapper
    def visit(self, tree, lower, upper):
        f = getattr(self, tree.data)
        wrapper = getattr(f, &#39;visit_wrapper&#39;, None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta, lower, upper)
        else:
            return f(tree)

    def temporal(self, tree, lower, upper):
        # temporal has only one child
        return self.visit(tree.children[0], lower, upper)

    def and_(self, tree, lower, upper):
        # and_ has two children
        left = self.visit(tree.children[0], lower, upper)
        right = self.visit(tree.children[1], lower, upper)
        return np.nanmin([left, right])

    def or_(self, tree, lower, upper):
        # or_ has two children
        left = self.visit(tree.children[0], lower, upper)
        right = self.visit(tree.children[1], lower, upper)
        return np.nanmax([left, right])

    def xor_(self, tree, lower, upper):
        # xor_ has two children
        left = self.visit(tree.children[0], lower, upper)
        right = self.visit(tree.children[1], lower, upper)
        # a XOR b = (a &amp; !b) | (!a &amp; b)
        a_notb = np.nanmin([left, -right])
        nota_b = np.nanmin([-left, right])
        return np.nanmax([a_notb, nota_b])

    def implies_(self, tree, lower, upper):
        # implies_ has two children
        left = self.visit(tree.children[0], lower, upper)
        right = self.visit(tree.children[1], lower, upper)
        return np.nanmax([-left, right])  # works because a -&gt; b == !a v b

    def not_(self, tree, lower, upper):
        # not_ has a single child
        return -self.visit(tree.children[0], lower, upper)

    def eventually(self, tree, lower, upper):
        results = []
        for i in range(lower, upper + 1):
            results.append(self.visit(tree.children[0], i, upper))
            # speedup in case the interpreter is run in boolean mode
            if not self.quantitative and results[-1] &gt;= 0:
                return 1.
        return np.nanmax(results)

    def eventually_bounded(self, tree, lower, upper):
        bound = tree.children[0]
        rel_bound_l = int(bound.children[0].children[0])
        rel_bound_u = int(bound.children[1].children[0])

        abs_bound_l, abs_bound_u = self.relative_to_absolute_bounds(rel_bound_l, rel_bound_u, lower, upper)
        # this happens when the relative lower bound references a point in time later than upper
        if abs_bound_l &gt; abs_bound_u:
            return np.nan

        # create a &#39;fake&#39; eventually tree and interpret it over new bounds
        eventually_tree = Tree(&#39;eventually&#39;, [tree.children[1]])
        return self.eventually(eventually_tree, abs_bound_l, abs_bound_u)

    def always(self, tree, lower, upper):
        # always has only one child
        results = []
        for i in range(lower, upper + 1):
            results.append(self.visit(tree.children[0], i, upper))
            # speedup in case the interpreter is run in boolean mode
            if not self.quantitative and results[-1] &lt; 0:
                return -1.
        return np.nanmin(results)

    def always_bounded(self, tree, lower, upper):
        bound = tree.children[0]
        rel_bound_l = int(bound.children[0].children[0])
        rel_bound_u = int(bound.children[1].children[0])

        abs_bound_l, abs_bound_u = self.relative_to_absolute_bounds(rel_bound_l, rel_bound_u, lower, upper)
        # this happens when the relative lower bound references a point in time later than upper
        if abs_bound_l &gt; abs_bound_u:
            return np.nan

        # create a &#39;fake&#39; always tree and interpret it over new bounds
        always_tree = Tree(&#39;always&#39;, [tree.children[1]])
        return self.always(always_tree, abs_bound_l, abs_bound_u)

    def next(self, tree, lower, upper):
        if lower + 1 &gt; upper:
            return np.nan

        # next always has only one child
        return self.visit(tree.children[0], lower + 1, upper)

    until_storage = dict()

    def until(self, tree, lower, upper):
        # final result
        result = -np.inf

        # store results of current tree evaluation in lookup table
        element = hash((tree.children[0], tree.children[1]))
        if element not in self.until_storage:
            self.until_storage[element] = {}
        # get dictionary of previous calls
        # stores calls of self.visit(tree.children[0], j, k). key is (i, k), value is result
        v2_dict = self.until_storage[element]

        for k in range(lower, upper + 1):
            v1 = self.visit(tree.children[1], k, upper)
            # this whole section is simply
            # v2 = min(self.visit(tree.children[0], j, k) for j in range(lower, k+1))
            v2 = np.inf
            for j in range(lower, k + 1):
                interval = (j, k)
                if interval not in v2_dict:
                    val = self.visit(tree.children[0], j, k)
                    v2_dict[interval] = val
                    if val &lt; v2:
                        v2 = val
                else:
                    val = v2_dict[interval]
                    if val &lt; v2:
                        v2 = val
            val = np.nanmin([v1, v2])
            if val &gt; result:
                result = val
        return result

    def until_bounded(self, tree, lower, upper):
        bound = tree.children[1]
        rel_bound_l = int(bound.children[0].children[0])
        rel_bound_u = int(bound.children[1].children[0])

        abs_bound_l, abs_bound_u = self.relative_to_absolute_bounds(rel_bound_l, rel_bound_u, lower, upper)
        # this happens when the relative lower bound references a point in time later than upper
        if abs_bound_l &gt; abs_bound_u:
            return np.nan

        # create a &#39;fake&#39; until tree and interpret it over new bounds
        until_tree = Tree(&#39;until&#39;, [tree.children[0], tree.children[2]])
        return self.always(until_tree, abs_bound_l, abs_bound_u)

    def spatial(self, tree, lower, upper):
        # check if this spatial formula has already been evaluated for this time point
        element = hash((tree, lower))  # compute hash once
        if element not in self._spatial_dict:
            # set global time for evaluation of formula
            self._spatial_interpreter.set_global_time(lower)
            val = self._spatial_interpreter.transform(tree)
            self._spatial_dict[element] = val
        return self._spatial_dict[element]


class Spatial(object):
    &#34;&#34;&#34;
    Spatial parser (+ interpreter)
    &#34;&#34;&#34;

    def __init__(self, quantitative: bool = False):
        &#34;&#34;&#34;
        Initializes the Spatial object
        Args:
            quantitative: True if quantitative semantics are desired
        &#34;&#34;&#34;
        grammar = os.path.dirname(__file__) + &#34;/spatial.lark&#34;
        self._parser = Lark.open(grammar, parser=&#39;lalr&#39;)
        self._spatial_interpreter = SpatRelInterpreter()
        self._tl_interpreter = SpatialInterpreter(self._spatial_interpreter, quantitative=quantitative)
        self.quantitative = quantitative

    @property
    def quantitative(self) -&gt; bool:
        return self._quantitative

    @quantitative.setter
    def quantitative(self, quantitative: bool):
        self._quantitative = quantitative
        self._tl_interpreter.quantitative = quantitative

    def reset_spatial_dict(self):
        &#34;&#34;&#34;
        Resets the spatial interpreter call history
        &#34;&#34;&#34;
        self._tl_interpreter._spatial_dict = {}

    def parse(self, formula: str) -&gt; Tree:
        &#34;&#34;&#34;
        Parses a given formula to a tree object
        Args:
            formula: Formula to parse

        Returns: Tree object of parsed formula

        &#34;&#34;&#34;
        try:
            self.reset_spatial_dict()  # every time you parse a new formula, reset the spatial dict
            return self._parser.parse(formula)
        except Exception as e:
            print(e)
            return None

    def interpret(self, formula: Tree, lower=0, upper=0):
        &#34;&#34;&#34;
        Interprets a given tree
        Args:
            formula: The tree of the formula
            lower: lower time bound for semantics
            upper: upper time bound for semantics

        Returns: Value of interpreted formula

        &#34;&#34;&#34;

        # check if relative time has been used
        rel_time = self.min_time_of_formula(formula)
        # return NAN if start time does not allow to evaluate formula
        if rel_time &gt; lower:
            warnings.warn(f&#34;&lt;Interpreter/interpret&gt;: Cannot evalute formula from time step {lower} &#34;
                          f&#34;since the formalue is valid from {rel_time}!&#34;)
            return np.NAN

        try:
            val = self._tl_interpreter.visit(formula, lower, upper)
            if self.quantitative:
                return val
            else:
                return val &gt;= 0
        except Exception as e:
            print(e)
            return None

    @staticmethod
    def svg_from_tree(formula: Tree, filename, rankdir=&#34;LR&#34;, **kwargs):
        &#34;&#34;&#34;
        Saves tree object to a svg vector graphics file
        Args:
            formula: The tree of the formula
            filename: The filename
            rankdir: params for pydot
            **kwargs: params for pydot

        &#34;&#34;&#34;
        graph = pydot__tree_to_graph(formula, rankdir, **kwargs)
        graph.write_svg(filename)

    @staticmethod
    def png_from_tree(formula: Tree, filename, rankdir=&#34;LR&#34;, **kwargs):
        &#34;&#34;&#34;
        Saves tree object to a png graphics file
        Args:
            formula: The tree of the formula
            filename: The filename
            rankdir: params for pydot
            **kwargs: params for pydot

        &#34;&#34;&#34;
        graph = pydot__tree_to_graph(formula, rankdir, **kwargs)
        graph.write_png(filename)

    @staticmethod
    def determine_variables(formula: Tree):
        &#34;&#34;&#34;
        Determines all variables within a formula (given as a tree)
        Args:
            formula: The formula to check

        Returns: Set of all variable names

        &#34;&#34;&#34;
        iter = formula.find_data(&#39;var&#39;)
        vars = set()
        for v in iter:
            vars.add(v.children[0].title())
        return vars

    def check_variables(self, formula: Tree) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the interpreter stores all variables required to interpret a given formula
        Args:
            formula: The formula to check as a tree

        Returns: True if interpreter stores all necessary variables and False otherwise

        &#34;&#34;&#34;
        vars = self.determine_variables(formula)
        for v in vars:
            if v.lower() not in self._tl_interpreter.vars.keys():
                return False
        return True

    @staticmethod
    def min_time_of_formula(formula: Tree) -&gt; int:
        &#34;&#34;&#34;
        If the formula contains relative time references (variable plus time reference), then the formula can only
        be evaluated when the minimum time has been reached in the interpreter. This function returns the minimum
        required time to evaluate the formula.
        Args:
            formula: The formula to check

        Returns: The minimum time rquired to evaluate the formula

        &#34;&#34;&#34;

        iter = formula.find_data(&#39;var_at&#39;)  # tag used for variables with time reference
        vars = [0]
        for v in iter:
            time = float(v.children[1].children[0].title())
            assert time &gt;= 0
            vars.append(time)
        return np.max(vars)

    def update_variables(self, vars: dict):
        &#34;&#34;&#34;
        Update the set of variables in the interpreter
        Args:
            vars: The new set of variables

        &#34;&#34;&#34;
        self._tl_interpreter.vars = vars

    def assign_variable(self, name, value):
        &#34;&#34;&#34;
        Assigns a variable to the interpreter
        Args:
            name: Name of the variable
            value: Value of the variable

        &#34;&#34;&#34;

        # if isinstance(value, ObjectInTime):
        #    self._tl_interpreter.assign_var(name, value)
        # elif isinstance(value, SpatialInterface):
        #    self._tl_interpreter.assign_var(name, StaticObject(value))
        # else:
        self._spatial_interpreter.assign_var(name, value)

    def parse_and_interpret(self, formula: str):
        &#34;&#34;&#34;
        Parses and interprets a given formula
        Args:
            formula: Formula as string

        Returns:

        &#34;&#34;&#34;
        self.reset_spatial_dict()
        return self.interpret(self.parse(formula))

    def save_to_file(self, file: str):
        &#34;&#34;&#34;
        Saves the state of the interpreter to the files system
        Args:
            file: The filename

        &#34;&#34;&#34;
        try:
            pickle.dump(self._spatial_interpreter, open(file, &#39;wb&#39;))
        except Exception as e:
            print(e)

    def from_file(self, file: str):
        &#34;&#34;&#34;
        Restores an interpreter from the file system
        Args:
            file: The filename

        &#34;&#34;&#34;
        try:
            self._spatial_interpreter = pickle.load(open(file, &#39;rb&#39;))
        except Exception as e:
            print(e)

    @staticmethod
    def write_formulas_to_file(file: str, formulas: list):
        &#34;&#34;&#34;
        Writes a list of formulas to the file system
        Args:
            file: The filename
            formulas: The list of formulas to store

        &#34;&#34;&#34;
        try:
            pickle.dump(formulas, open(file, &#39;wb&#39;))
        except Exception as e:
            print(e)

    @staticmethod
    def load_formulas_from_file(file: str) -&gt; list:
        &#34;&#34;&#34;
        Loads a list of formulas from the file system
        Args:
            file: The filename

        Returns: list of formulas as strings

        &#34;&#34;&#34;
        try:
            return pickle.load(open(file, &#39;rb&#39;))
        except Exception as e:
            print(e)


if __name__ == &#34;__main__&#34;:
    print(&#34;WOW&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spatial.logic.SpatRelInterpreter"><code class="flex name class">
<span>class <span class="ident">SpatRelInterpreter</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interpreter for spatial relations. Delegates parsed tree to corresponding operations.</p>
<p>Initializes the interpreter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpatRelInterpreter(Transformer):
    &#34;&#34;&#34;
    Interpreter for spatial relations. Delegates parsed tree to corresponding operations.
    &#34;&#34;&#34;

    # from operator import neg, and_ as b_and, or_ as b_or
    # from operator import and_, or_, not_
    number = float

    def __init__(self):
        &#34;&#34;&#34;
        Initializes the interpreter
        &#34;&#34;&#34;
        super().__init__()
        self.vars: Dict[str, ObjectInTime] = {}
        self.number_vars: Dict[str, float] = {}
        self._global_time = 0

    def set_global_time(self, time: int):
        assert time &gt;= 0, &#34;&lt;Interpreter&gt;: global time must be non-negative! Got: {}&#34;.format(time)
        self._global_time = time

    @staticmethod
    def spatial(a):
        &#34;&#34;&#34;
        Maps quantitative semantics to bool domain
        Args:
            a: The float value

        Returns: True if val&gt;=0 and False otherwise

        &#34;&#34;&#34;
        return a

    @staticmethod
    def and_(a, b) -&gt; float:
        &#34;&#34;&#34;
        Computes the quantitative semantics of AND operator
        Args:
            a: predicate left of operator
            b: predicate right of operator

        Returns: min(a,b)

        &#34;&#34;&#34;
        return np.min([a, b])

    @staticmethod
    def or_(a, b) -&gt; float:
        &#34;&#34;&#34;
        Computes the quantitative semantics of OR operator
        Args:
            a: predicate left of operator
            b: predicate right of operator

        Returns: max(a,b)

        &#34;&#34;&#34;
        return np.max([a, b])

    @staticmethod
    def xor_(a, b) -&gt; float:
        &#34;&#34;&#34;
        Computes the quantitative semantics of XOR operator
        Args:
            a: predicate left of operator
            b: predicate right of operator

        Returns: max(a,b)

        &#34;&#34;&#34;
        # a XOR b = (a &amp; !b) | (!a &amp; b)
        a_notb = np.min([a, -b])
        nota_b = np.min([-a, b])
        return np.max([a_notb, nota_b])

    @staticmethod
    def implies_(a, b) -&gt; float:
        &#34;&#34;&#34;
        Computes the quantitative semantics of IMPLIES operator
        Args:
            a: predicate left of operator
            b: predicate right of operator

        Returns: max(a,b)

        &#34;&#34;&#34;
        # a -&gt; b = !a | b
        return np.max([-a, b])

    @staticmethod
    def not_(a) -&gt; float:
        &#34;&#34;&#34;
        Computes the quantitative semantics of not operator
        Args:
            a: predicate to negate

        Returns: -a

        &#34;&#34;&#34;
        return -a

    @property
    def vars(self) -&gt; dict:
        &#34;&#34;&#34;
        Dictionary of stored (name, variable) pairs
        Returns: dictionary

        &#34;&#34;&#34;
        return self._vars

    @vars.setter
    def vars(self, vars: dict):
        &#34;&#34;&#34;
        Sets the dictionary of stored (name, variable) pairs
        Args:
            vars: Dictionary

        &#34;&#34;&#34;
        if len(vars) &gt; 1:
            elements = list(vars.values())
            assert all([isinstance(k, type(elements[0])) for k in
                        elements]), &#39;&lt;SpatialInterpreter&gt;: only one type of obstacle currently supported!&#39;
        self._vars = vars

    @property
    def number_vars(self) -&gt; dict:
        &#34;&#34;&#34;
        Returns the dictionary of stored (name, numerical variable) pairs
        Returns: dictionary

        &#34;&#34;&#34;
        return self._number_vars

    @number_vars.setter
    def number_vars(self, number_vars: dict):
        &#34;&#34;&#34;
        Sets the dictionary of stored (name, numerical variable) pairs
        Args:
            number_vars: dictionary

        &#34;&#34;&#34;
        assert len(number_vars) == 0 or all([isinstance(k, (float, int)) for k in
                                             [number_vars.values()]]), &#39;&lt;SpatialInterpreter&gt;: only numbers supported!&#39;
        self._number_vars = number_vars

    def assign_var(self, name: str, value: ObjectInTime):
        &#34;&#34;&#34;
        Assigns a new variable to the interpreter
        Args:
            name: Name of the variable
            value: Value of the variables (spatial interface object or int/float)

        &#34;&#34;&#34;

        assert isinstance(name, str), &#39;&lt;Logic&gt;: name must be of type string! Got {}&#39;.format(name)

        if isinstance(value, (int, float)):
            self.number_vars[name.lower()] = value
        else:

            assert isinstance(value, ObjectInTime), &#39;&lt;Logic&gt;: value must be of type &#39; \
                                                    &#39;ObjectInTime! Got {}&#39;.format(
                value)

            self.vars[name.lower()] = value
        return value

    def var(self, name: str) -&gt; SpatialInterface:
        &#34;&#34;&#34;
        Returns the variable corresponding to the provided name
        Args:
            name: Name of the variable

        Returns: spatial interface object of name

        &#34;&#34;&#34;

        # query latest time step
        return self.var_at(name, 0)

    def var_at(self, name: str, rel_time: int) -&gt; SpatialInterface:
        &#34;&#34;&#34;
        Returns the variable corresponding to the provided name and time step
        Args:
            name: Name of the variable
            rel_time: relative time identifier

        Returns: spatial interface object of name

        &#34;&#34;&#34;

        assert rel_time &gt;= 0., &#39;&#39;

        try:
            obj: ObjectInTime = self.vars[name.lower()]
        except KeyError:
            raise Exception(&#34;Variable not found: %s&#34; % name)

        try:
            return obj.getObject(self._global_time - rel_time)
        except Exception:
            raise Exception(&#34;Time step index t={} not found&#34;.format(self._global_time - rel_time))

    @staticmethod
    def enlarge(o: SpatialInterface, radius: float):
        return o.enlarge(radius)

    def numeric_var(self, name):
        &#34;&#34;&#34;
        Returns the numeric variable of a specified name
        Args:
            name: The specified name

        Returns: int/float object corresponding to specified name

        &#34;&#34;&#34;
        try:
            return self.number_vars[name.lower()]
        except KeyError:
            raise Exception(&#34;Variable not found: %s&#34; % name)

    @staticmethod
    def left_of(left: SpatialInterface, right: SpatialInterface):
        return left.left_of(right)

    @staticmethod
    def right_of(left: SpatialInterface, right: SpatialInterface):
        return left.right_of(right)

    @staticmethod
    def below_of(left: SpatialInterface, right: SpatialInterface):
        return left.below(right)

    @staticmethod
    def above_of(left: SpatialInterface, right: SpatialInterface):
        return left.above(right)

    @staticmethod
    def overlap(left: SpatialInterface, right: SpatialInterface):
        return left.overlap(right)

    @staticmethod
    def touching(left: SpatialInterface, right: SpatialInterface):
        return left.touching(right)

    @staticmethod
    def far_from(left: SpatialInterface, right: SpatialInterface):
        return left.far_from(right)

    @staticmethod
    def close_to(left: SpatialInterface, right: SpatialInterface):
        return left.close_to(right)

    @staticmethod
    def enclosed_in(left: SpatialInterface, right: SpatialInterface):
        return left.enclosed_in(right)

    @staticmethod
    def comparison(left: SpatialInterface, right: SpatialInterface):
        return [left, right]

    @staticmethod
    def moved(left: SpatialInterface, right: SpatialInterface):
        val = left.enclosed_in(right.enlarge(25))
        return val if np.isclose(val, 0) else -val

    @staticmethod
    def operator(value):
        &#34;&#34;&#34;
        Maps operators (&lt;=,&gt;=,=) to numpy functions
        Args:
            value: The operator to map

        Returns: Numpy functions object

        &#34;&#34;&#34;
        # &#34;&lt;=&#34; | &#34;&gt;=&#34; | &#34;==&#34;
        if value == &#34;&lt;=&#34;:
            return np.less_equal
        if value == &#34;&gt;=&#34;:
            return np.greater_equal
        if value == &#34;==&#34;:
            return np.equal

    @staticmethod
    def closer_to(left: SpatialInterface, right: list):
        return left.closer_to_than(right[0], right[1])

    @staticmethod
    def distance(left: SpatialInterface, right: SpatialInterface, fun, eps):
        return left.distance_compare(right, eps, fun)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>lark.visitors.Transformer</li>
<li>lark.visitors._Decoratable</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spatial.logic.SpatRelInterpreter.number"><code class="name">var <span class="ident">number</span></code></dt>
<dd>
<div class="desc"><p>Convert a string or number to a floating point number, if possible.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spatial.logic.SpatRelInterpreter.number_vars"><code class="name">var <span class="ident">number_vars</span> : dict</code></dt>
<dd>
<div class="desc"><p>Returns the dictionary of stored (name, numerical variable) pairs
Returns: dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def number_vars(self) -&gt; dict:
    &#34;&#34;&#34;
    Returns the dictionary of stored (name, numerical variable) pairs
    Returns: dictionary

    &#34;&#34;&#34;
    return self._number_vars</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.vars"><code class="name">var <span class="ident">vars</span> : dict</code></dt>
<dd>
<div class="desc"><p>Dictionary of stored (name, variable) pairs
Returns: dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vars(self) -&gt; dict:
    &#34;&#34;&#34;
    Dictionary of stored (name, variable) pairs
    Returns: dictionary

    &#34;&#34;&#34;
    return self._vars</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spatial.logic.SpatRelInterpreter.above_of"><code class="name flex">
<span>def <span class="ident">above_of</span></span>(<span>left: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, right: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def above_of(left: SpatialInterface, right: SpatialInterface):
    return left.above(right)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.and_"><code class="name flex">
<span>def <span class="ident">and_</span></span>(<span>a, b) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the quantitative semantics of AND operator</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a</code></strong></dt>
<dd>predicate left of operator</dd>
<dt><strong><code>b</code></strong></dt>
<dd>predicate right of operator</dd>
</dl>
<p>Returns: min(a,b)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def and_(a, b) -&gt; float:
    &#34;&#34;&#34;
    Computes the quantitative semantics of AND operator
    Args:
        a: predicate left of operator
        b: predicate right of operator

    Returns: min(a,b)

    &#34;&#34;&#34;
    return np.min([a, b])</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.assign_var"><code class="name flex">
<span>def <span class="ident">assign_var</span></span>(<span>self, name: str, value: <a title="spatial.geometry.ObjectInTime" href="geometry.html#spatial.geometry.ObjectInTime">ObjectInTime</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Assigns a new variable to the interpreter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the variable</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Value of the variables (spatial interface object or int/float)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_var(self, name: str, value: ObjectInTime):
    &#34;&#34;&#34;
    Assigns a new variable to the interpreter
    Args:
        name: Name of the variable
        value: Value of the variables (spatial interface object or int/float)

    &#34;&#34;&#34;

    assert isinstance(name, str), &#39;&lt;Logic&gt;: name must be of type string! Got {}&#39;.format(name)

    if isinstance(value, (int, float)):
        self.number_vars[name.lower()] = value
    else:

        assert isinstance(value, ObjectInTime), &#39;&lt;Logic&gt;: value must be of type &#39; \
                                                &#39;ObjectInTime! Got {}&#39;.format(
            value)

        self.vars[name.lower()] = value
    return value</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.below_of"><code class="name flex">
<span>def <span class="ident">below_of</span></span>(<span>left: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, right: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def below_of(left: SpatialInterface, right: SpatialInterface):
    return left.below(right)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.close_to"><code class="name flex">
<span>def <span class="ident">close_to</span></span>(<span>left: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, right: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def close_to(left: SpatialInterface, right: SpatialInterface):
    return left.close_to(right)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.closer_to"><code class="name flex">
<span>def <span class="ident">closer_to</span></span>(<span>left: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, right: list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def closer_to(left: SpatialInterface, right: list):
    return left.closer_to_than(right[0], right[1])</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.comparison"><code class="name flex">
<span>def <span class="ident">comparison</span></span>(<span>left: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, right: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def comparison(left: SpatialInterface, right: SpatialInterface):
    return [left, right]</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>left: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, right: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, fun, eps)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def distance(left: SpatialInterface, right: SpatialInterface, fun, eps):
    return left.distance_compare(right, eps, fun)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.enclosed_in"><code class="name flex">
<span>def <span class="ident">enclosed_in</span></span>(<span>left: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, right: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def enclosed_in(left: SpatialInterface, right: SpatialInterface):
    return left.enclosed_in(right)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.enlarge"><code class="name flex">
<span>def <span class="ident">enlarge</span></span>(<span>o: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, radius: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def enlarge(o: SpatialInterface, radius: float):
    return o.enlarge(radius)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.far_from"><code class="name flex">
<span>def <span class="ident">far_from</span></span>(<span>left: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, right: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def far_from(left: SpatialInterface, right: SpatialInterface):
    return left.far_from(right)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.implies_"><code class="name flex">
<span>def <span class="ident">implies_</span></span>(<span>a, b) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the quantitative semantics of IMPLIES operator</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a</code></strong></dt>
<dd>predicate left of operator</dd>
<dt><strong><code>b</code></strong></dt>
<dd>predicate right of operator</dd>
</dl>
<p>Returns: max(a,b)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def implies_(a, b) -&gt; float:
    &#34;&#34;&#34;
    Computes the quantitative semantics of IMPLIES operator
    Args:
        a: predicate left of operator
        b: predicate right of operator

    Returns: max(a,b)

    &#34;&#34;&#34;
    # a -&gt; b = !a | b
    return np.max([-a, b])</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.left_of"><code class="name flex">
<span>def <span class="ident">left_of</span></span>(<span>left: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, right: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def left_of(left: SpatialInterface, right: SpatialInterface):
    return left.left_of(right)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.moved"><code class="name flex">
<span>def <span class="ident">moved</span></span>(<span>left: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, right: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def moved(left: SpatialInterface, right: SpatialInterface):
    val = left.enclosed_in(right.enlarge(25))
    return val if np.isclose(val, 0) else -val</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.not_"><code class="name flex">
<span>def <span class="ident">not_</span></span>(<span>a) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the quantitative semantics of not operator</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a</code></strong></dt>
<dd>predicate to negate</dd>
</dl>
<p>Returns: -a</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def not_(a) -&gt; float:
    &#34;&#34;&#34;
    Computes the quantitative semantics of not operator
    Args:
        a: predicate to negate

    Returns: -a

    &#34;&#34;&#34;
    return -a</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.numeric_var"><code class="name flex">
<span>def <span class="ident">numeric_var</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the numeric variable of a specified name</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The specified name</dd>
</dl>
<p>Returns: int/float object corresponding to specified name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_var(self, name):
    &#34;&#34;&#34;
    Returns the numeric variable of a specified name
    Args:
        name: The specified name

    Returns: int/float object corresponding to specified name

    &#34;&#34;&#34;
    try:
        return self.number_vars[name.lower()]
    except KeyError:
        raise Exception(&#34;Variable not found: %s&#34; % name)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.operator"><code class="name flex">
<span>def <span class="ident">operator</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Maps operators (&lt;=,&gt;=,=) to numpy functions</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>The operator to map</dd>
</dl>
<p>Returns: Numpy functions object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def operator(value):
    &#34;&#34;&#34;
    Maps operators (&lt;=,&gt;=,=) to numpy functions
    Args:
        value: The operator to map

    Returns: Numpy functions object

    &#34;&#34;&#34;
    # &#34;&lt;=&#34; | &#34;&gt;=&#34; | &#34;==&#34;
    if value == &#34;&lt;=&#34;:
        return np.less_equal
    if value == &#34;&gt;=&#34;:
        return np.greater_equal
    if value == &#34;==&#34;:
        return np.equal</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.or_"><code class="name flex">
<span>def <span class="ident">or_</span></span>(<span>a, b) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the quantitative semantics of OR operator</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a</code></strong></dt>
<dd>predicate left of operator</dd>
<dt><strong><code>b</code></strong></dt>
<dd>predicate right of operator</dd>
</dl>
<p>Returns: max(a,b)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def or_(a, b) -&gt; float:
    &#34;&#34;&#34;
    Computes the quantitative semantics of OR operator
    Args:
        a: predicate left of operator
        b: predicate right of operator

    Returns: max(a,b)

    &#34;&#34;&#34;
    return np.max([a, b])</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.overlap"><code class="name flex">
<span>def <span class="ident">overlap</span></span>(<span>left: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, right: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def overlap(left: SpatialInterface, right: SpatialInterface):
    return left.overlap(right)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.right_of"><code class="name flex">
<span>def <span class="ident">right_of</span></span>(<span>left: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, right: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def right_of(left: SpatialInterface, right: SpatialInterface):
    return left.right_of(right)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.set_global_time"><code class="name flex">
<span>def <span class="ident">set_global_time</span></span>(<span>self, time: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_global_time(self, time: int):
    assert time &gt;= 0, &#34;&lt;Interpreter&gt;: global time must be non-negative! Got: {}&#34;.format(time)
    self._global_time = time</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.spatial"><code class="name flex">
<span>def <span class="ident">spatial</span></span>(<span>a)</span>
</code></dt>
<dd>
<div class="desc"><p>Maps quantitative semantics to bool domain</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a</code></strong></dt>
<dd>The float value</dd>
</dl>
<p>Returns: True if val&gt;=0 and False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def spatial(a):
    &#34;&#34;&#34;
    Maps quantitative semantics to bool domain
    Args:
        a: The float value

    Returns: True if val&gt;=0 and False otherwise

    &#34;&#34;&#34;
    return a</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.touching"><code class="name flex">
<span>def <span class="ident">touching</span></span>(<span>left: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>, right: <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def touching(left: SpatialInterface, right: SpatialInterface):
    return left.touching(right)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.var"><code class="name flex">
<span>def <span class="ident">var</span></span>(<span>self, name: str) ‑> <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the variable corresponding to the provided name</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the variable</dd>
</dl>
<p>Returns: spatial interface object of name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def var(self, name: str) -&gt; SpatialInterface:
    &#34;&#34;&#34;
    Returns the variable corresponding to the provided name
    Args:
        name: Name of the variable

    Returns: spatial interface object of name

    &#34;&#34;&#34;

    # query latest time step
    return self.var_at(name, 0)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.var_at"><code class="name flex">
<span>def <span class="ident">var_at</span></span>(<span>self, name: str, rel_time: int) ‑> <a title="spatial.geometry.SpatialInterface" href="geometry.html#spatial.geometry.SpatialInterface">SpatialInterface</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the variable corresponding to the provided name and time step</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the variable</dd>
<dt><strong><code>rel_time</code></strong></dt>
<dd>relative time identifier</dd>
</dl>
<p>Returns: spatial interface object of name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def var_at(self, name: str, rel_time: int) -&gt; SpatialInterface:
    &#34;&#34;&#34;
    Returns the variable corresponding to the provided name and time step
    Args:
        name: Name of the variable
        rel_time: relative time identifier

    Returns: spatial interface object of name

    &#34;&#34;&#34;

    assert rel_time &gt;= 0., &#39;&#39;

    try:
        obj: ObjectInTime = self.vars[name.lower()]
    except KeyError:
        raise Exception(&#34;Variable not found: %s&#34; % name)

    try:
        return obj.getObject(self._global_time - rel_time)
    except Exception:
        raise Exception(&#34;Time step index t={} not found&#34;.format(self._global_time - rel_time))</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatRelInterpreter.xor_"><code class="name flex">
<span>def <span class="ident">xor_</span></span>(<span>a, b) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the quantitative semantics of XOR operator</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a</code></strong></dt>
<dd>predicate left of operator</dd>
<dt><strong><code>b</code></strong></dt>
<dd>predicate right of operator</dd>
</dl>
<p>Returns: max(a,b)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def xor_(a, b) -&gt; float:
    &#34;&#34;&#34;
    Computes the quantitative semantics of XOR operator
    Args:
        a: predicate left of operator
        b: predicate right of operator

    Returns: max(a,b)

    &#34;&#34;&#34;
    # a XOR b = (a &amp; !b) | (!a &amp; b)
    a_notb = np.min([a, -b])
    nota_b = np.min([-a, b])
    return np.max([a_notb, nota_b])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spatial.logic.Spatial"><code class="flex name class">
<span>class <span class="ident">Spatial</span></span>
<span>(</span><span>quantitative: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Spatial parser (+ interpreter)</p>
<p>Initializes the Spatial object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>quantitative</code></strong></dt>
<dd>True if quantitative semantics are desired</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spatial(object):
    &#34;&#34;&#34;
    Spatial parser (+ interpreter)
    &#34;&#34;&#34;

    def __init__(self, quantitative: bool = False):
        &#34;&#34;&#34;
        Initializes the Spatial object
        Args:
            quantitative: True if quantitative semantics are desired
        &#34;&#34;&#34;
        grammar = os.path.dirname(__file__) + &#34;/spatial.lark&#34;
        self._parser = Lark.open(grammar, parser=&#39;lalr&#39;)
        self._spatial_interpreter = SpatRelInterpreter()
        self._tl_interpreter = SpatialInterpreter(self._spatial_interpreter, quantitative=quantitative)
        self.quantitative = quantitative

    @property
    def quantitative(self) -&gt; bool:
        return self._quantitative

    @quantitative.setter
    def quantitative(self, quantitative: bool):
        self._quantitative = quantitative
        self._tl_interpreter.quantitative = quantitative

    def reset_spatial_dict(self):
        &#34;&#34;&#34;
        Resets the spatial interpreter call history
        &#34;&#34;&#34;
        self._tl_interpreter._spatial_dict = {}

    def parse(self, formula: str) -&gt; Tree:
        &#34;&#34;&#34;
        Parses a given formula to a tree object
        Args:
            formula: Formula to parse

        Returns: Tree object of parsed formula

        &#34;&#34;&#34;
        try:
            self.reset_spatial_dict()  # every time you parse a new formula, reset the spatial dict
            return self._parser.parse(formula)
        except Exception as e:
            print(e)
            return None

    def interpret(self, formula: Tree, lower=0, upper=0):
        &#34;&#34;&#34;
        Interprets a given tree
        Args:
            formula: The tree of the formula
            lower: lower time bound for semantics
            upper: upper time bound for semantics

        Returns: Value of interpreted formula

        &#34;&#34;&#34;

        # check if relative time has been used
        rel_time = self.min_time_of_formula(formula)
        # return NAN if start time does not allow to evaluate formula
        if rel_time &gt; lower:
            warnings.warn(f&#34;&lt;Interpreter/interpret&gt;: Cannot evalute formula from time step {lower} &#34;
                          f&#34;since the formalue is valid from {rel_time}!&#34;)
            return np.NAN

        try:
            val = self._tl_interpreter.visit(formula, lower, upper)
            if self.quantitative:
                return val
            else:
                return val &gt;= 0
        except Exception as e:
            print(e)
            return None

    @staticmethod
    def svg_from_tree(formula: Tree, filename, rankdir=&#34;LR&#34;, **kwargs):
        &#34;&#34;&#34;
        Saves tree object to a svg vector graphics file
        Args:
            formula: The tree of the formula
            filename: The filename
            rankdir: params for pydot
            **kwargs: params for pydot

        &#34;&#34;&#34;
        graph = pydot__tree_to_graph(formula, rankdir, **kwargs)
        graph.write_svg(filename)

    @staticmethod
    def png_from_tree(formula: Tree, filename, rankdir=&#34;LR&#34;, **kwargs):
        &#34;&#34;&#34;
        Saves tree object to a png graphics file
        Args:
            formula: The tree of the formula
            filename: The filename
            rankdir: params for pydot
            **kwargs: params for pydot

        &#34;&#34;&#34;
        graph = pydot__tree_to_graph(formula, rankdir, **kwargs)
        graph.write_png(filename)

    @staticmethod
    def determine_variables(formula: Tree):
        &#34;&#34;&#34;
        Determines all variables within a formula (given as a tree)
        Args:
            formula: The formula to check

        Returns: Set of all variable names

        &#34;&#34;&#34;
        iter = formula.find_data(&#39;var&#39;)
        vars = set()
        for v in iter:
            vars.add(v.children[0].title())
        return vars

    def check_variables(self, formula: Tree) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the interpreter stores all variables required to interpret a given formula
        Args:
            formula: The formula to check as a tree

        Returns: True if interpreter stores all necessary variables and False otherwise

        &#34;&#34;&#34;
        vars = self.determine_variables(formula)
        for v in vars:
            if v.lower() not in self._tl_interpreter.vars.keys():
                return False
        return True

    @staticmethod
    def min_time_of_formula(formula: Tree) -&gt; int:
        &#34;&#34;&#34;
        If the formula contains relative time references (variable plus time reference), then the formula can only
        be evaluated when the minimum time has been reached in the interpreter. This function returns the minimum
        required time to evaluate the formula.
        Args:
            formula: The formula to check

        Returns: The minimum time rquired to evaluate the formula

        &#34;&#34;&#34;

        iter = formula.find_data(&#39;var_at&#39;)  # tag used for variables with time reference
        vars = [0]
        for v in iter:
            time = float(v.children[1].children[0].title())
            assert time &gt;= 0
            vars.append(time)
        return np.max(vars)

    def update_variables(self, vars: dict):
        &#34;&#34;&#34;
        Update the set of variables in the interpreter
        Args:
            vars: The new set of variables

        &#34;&#34;&#34;
        self._tl_interpreter.vars = vars

    def assign_variable(self, name, value):
        &#34;&#34;&#34;
        Assigns a variable to the interpreter
        Args:
            name: Name of the variable
            value: Value of the variable

        &#34;&#34;&#34;

        # if isinstance(value, ObjectInTime):
        #    self._tl_interpreter.assign_var(name, value)
        # elif isinstance(value, SpatialInterface):
        #    self._tl_interpreter.assign_var(name, StaticObject(value))
        # else:
        self._spatial_interpreter.assign_var(name, value)

    def parse_and_interpret(self, formula: str):
        &#34;&#34;&#34;
        Parses and interprets a given formula
        Args:
            formula: Formula as string

        Returns:

        &#34;&#34;&#34;
        self.reset_spatial_dict()
        return self.interpret(self.parse(formula))

    def save_to_file(self, file: str):
        &#34;&#34;&#34;
        Saves the state of the interpreter to the files system
        Args:
            file: The filename

        &#34;&#34;&#34;
        try:
            pickle.dump(self._spatial_interpreter, open(file, &#39;wb&#39;))
        except Exception as e:
            print(e)

    def from_file(self, file: str):
        &#34;&#34;&#34;
        Restores an interpreter from the file system
        Args:
            file: The filename

        &#34;&#34;&#34;
        try:
            self._spatial_interpreter = pickle.load(open(file, &#39;rb&#39;))
        except Exception as e:
            print(e)

    @staticmethod
    def write_formulas_to_file(file: str, formulas: list):
        &#34;&#34;&#34;
        Writes a list of formulas to the file system
        Args:
            file: The filename
            formulas: The list of formulas to store

        &#34;&#34;&#34;
        try:
            pickle.dump(formulas, open(file, &#39;wb&#39;))
        except Exception as e:
            print(e)

    @staticmethod
    def load_formulas_from_file(file: str) -&gt; list:
        &#34;&#34;&#34;
        Loads a list of formulas from the file system
        Args:
            file: The filename

        Returns: list of formulas as strings

        &#34;&#34;&#34;
        try:
            return pickle.load(open(file, &#39;rb&#39;))
        except Exception as e:
            print(e)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="spatial.logic.Spatial.determine_variables"><code class="name flex">
<span>def <span class="ident">determine_variables</span></span>(<span>formula: lark.tree.Tree)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines all variables within a formula (given as a tree)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>formula</code></strong></dt>
<dd>The formula to check</dd>
</dl>
<p>Returns: Set of all variable names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def determine_variables(formula: Tree):
    &#34;&#34;&#34;
    Determines all variables within a formula (given as a tree)
    Args:
        formula: The formula to check

    Returns: Set of all variable names

    &#34;&#34;&#34;
    iter = formula.find_data(&#39;var&#39;)
    vars = set()
    for v in iter:
        vars.add(v.children[0].title())
    return vars</code></pre>
</details>
</dd>
<dt id="spatial.logic.Spatial.load_formulas_from_file"><code class="name flex">
<span>def <span class="ident">load_formulas_from_file</span></span>(<span>file: str) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a list of formulas from the file system</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>The filename</dd>
</dl>
<p>Returns: list of formulas as strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_formulas_from_file(file: str) -&gt; list:
    &#34;&#34;&#34;
    Loads a list of formulas from the file system
    Args:
        file: The filename

    Returns: list of formulas as strings

    &#34;&#34;&#34;
    try:
        return pickle.load(open(file, &#39;rb&#39;))
    except Exception as e:
        print(e)</code></pre>
</details>
</dd>
<dt id="spatial.logic.Spatial.min_time_of_formula"><code class="name flex">
<span>def <span class="ident">min_time_of_formula</span></span>(<span>formula: lark.tree.Tree) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>If the formula contains relative time references (variable plus time reference), then the formula can only
be evaluated when the minimum time has been reached in the interpreter. This function returns the minimum
required time to evaluate the formula.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>formula</code></strong></dt>
<dd>The formula to check</dd>
</dl>
<p>Returns: The minimum time rquired to evaluate the formula</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def min_time_of_formula(formula: Tree) -&gt; int:
    &#34;&#34;&#34;
    If the formula contains relative time references (variable plus time reference), then the formula can only
    be evaluated when the minimum time has been reached in the interpreter. This function returns the minimum
    required time to evaluate the formula.
    Args:
        formula: The formula to check

    Returns: The minimum time rquired to evaluate the formula

    &#34;&#34;&#34;

    iter = formula.find_data(&#39;var_at&#39;)  # tag used for variables with time reference
    vars = [0]
    for v in iter:
        time = float(v.children[1].children[0].title())
        assert time &gt;= 0
        vars.append(time)
    return np.max(vars)</code></pre>
</details>
</dd>
<dt id="spatial.logic.Spatial.png_from_tree"><code class="name flex">
<span>def <span class="ident">png_from_tree</span></span>(<span>formula: lark.tree.Tree, filename, rankdir='LR', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves tree object to a png graphics file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>formula</code></strong></dt>
<dd>The tree of the formula</dd>
<dt><strong><code>filename</code></strong></dt>
<dd>The filename</dd>
<dt><strong><code>rankdir</code></strong></dt>
<dd>params for pydot</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>params for pydot</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def png_from_tree(formula: Tree, filename, rankdir=&#34;LR&#34;, **kwargs):
    &#34;&#34;&#34;
    Saves tree object to a png graphics file
    Args:
        formula: The tree of the formula
        filename: The filename
        rankdir: params for pydot
        **kwargs: params for pydot

    &#34;&#34;&#34;
    graph = pydot__tree_to_graph(formula, rankdir, **kwargs)
    graph.write_png(filename)</code></pre>
</details>
</dd>
<dt id="spatial.logic.Spatial.svg_from_tree"><code class="name flex">
<span>def <span class="ident">svg_from_tree</span></span>(<span>formula: lark.tree.Tree, filename, rankdir='LR', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves tree object to a svg vector graphics file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>formula</code></strong></dt>
<dd>The tree of the formula</dd>
<dt><strong><code>filename</code></strong></dt>
<dd>The filename</dd>
<dt><strong><code>rankdir</code></strong></dt>
<dd>params for pydot</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>params for pydot</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def svg_from_tree(formula: Tree, filename, rankdir=&#34;LR&#34;, **kwargs):
    &#34;&#34;&#34;
    Saves tree object to a svg vector graphics file
    Args:
        formula: The tree of the formula
        filename: The filename
        rankdir: params for pydot
        **kwargs: params for pydot

    &#34;&#34;&#34;
    graph = pydot__tree_to_graph(formula, rankdir, **kwargs)
    graph.write_svg(filename)</code></pre>
</details>
</dd>
<dt id="spatial.logic.Spatial.write_formulas_to_file"><code class="name flex">
<span>def <span class="ident">write_formulas_to_file</span></span>(<span>file: str, formulas: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a list of formulas to the file system</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>The filename</dd>
<dt><strong><code>formulas</code></strong></dt>
<dd>The list of formulas to store</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def write_formulas_to_file(file: str, formulas: list):
    &#34;&#34;&#34;
    Writes a list of formulas to the file system
    Args:
        file: The filename
        formulas: The list of formulas to store

    &#34;&#34;&#34;
    try:
        pickle.dump(formulas, open(file, &#39;wb&#39;))
    except Exception as e:
        print(e)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spatial.logic.Spatial.quantitative"><code class="name">var <span class="ident">quantitative</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def quantitative(self) -&gt; bool:
    return self._quantitative</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spatial.logic.Spatial.assign_variable"><code class="name flex">
<span>def <span class="ident">assign_variable</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Assigns a variable to the interpreter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the variable</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Value of the variable</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_variable(self, name, value):
    &#34;&#34;&#34;
    Assigns a variable to the interpreter
    Args:
        name: Name of the variable
        value: Value of the variable

    &#34;&#34;&#34;

    # if isinstance(value, ObjectInTime):
    #    self._tl_interpreter.assign_var(name, value)
    # elif isinstance(value, SpatialInterface):
    #    self._tl_interpreter.assign_var(name, StaticObject(value))
    # else:
    self._spatial_interpreter.assign_var(name, value)</code></pre>
</details>
</dd>
<dt id="spatial.logic.Spatial.check_variables"><code class="name flex">
<span>def <span class="ident">check_variables</span></span>(<span>self, formula: lark.tree.Tree) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the interpreter stores all variables required to interpret a given formula</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>formula</code></strong></dt>
<dd>The formula to check as a tree</dd>
</dl>
<p>Returns: True if interpreter stores all necessary variables and False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_variables(self, formula: Tree) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the interpreter stores all variables required to interpret a given formula
    Args:
        formula: The formula to check as a tree

    Returns: True if interpreter stores all necessary variables and False otherwise

    &#34;&#34;&#34;
    vars = self.determine_variables(formula)
    for v in vars:
        if v.lower() not in self._tl_interpreter.vars.keys():
            return False
    return True</code></pre>
</details>
</dd>
<dt id="spatial.logic.Spatial.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>self, file: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Restores an interpreter from the file system</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>The filename</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_file(self, file: str):
    &#34;&#34;&#34;
    Restores an interpreter from the file system
    Args:
        file: The filename

    &#34;&#34;&#34;
    try:
        self._spatial_interpreter = pickle.load(open(file, &#39;rb&#39;))
    except Exception as e:
        print(e)</code></pre>
</details>
</dd>
<dt id="spatial.logic.Spatial.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, formula: lark.tree.Tree, lower=0, upper=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Interprets a given tree</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>formula</code></strong></dt>
<dd>The tree of the formula</dd>
<dt><strong><code>lower</code></strong></dt>
<dd>lower time bound for semantics</dd>
<dt><strong><code>upper</code></strong></dt>
<dd>upper time bound for semantics</dd>
</dl>
<p>Returns: Value of interpreted formula</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, formula: Tree, lower=0, upper=0):
    &#34;&#34;&#34;
    Interprets a given tree
    Args:
        formula: The tree of the formula
        lower: lower time bound for semantics
        upper: upper time bound for semantics

    Returns: Value of interpreted formula

    &#34;&#34;&#34;

    # check if relative time has been used
    rel_time = self.min_time_of_formula(formula)
    # return NAN if start time does not allow to evaluate formula
    if rel_time &gt; lower:
        warnings.warn(f&#34;&lt;Interpreter/interpret&gt;: Cannot evalute formula from time step {lower} &#34;
                      f&#34;since the formalue is valid from {rel_time}!&#34;)
        return np.NAN

    try:
        val = self._tl_interpreter.visit(formula, lower, upper)
        if self.quantitative:
            return val
        else:
            return val &gt;= 0
    except Exception as e:
        print(e)
        return None</code></pre>
</details>
</dd>
<dt id="spatial.logic.Spatial.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, formula: str) ‑> lark.tree.Tree</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a given formula to a tree object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>formula</code></strong></dt>
<dd>Formula to parse</dd>
</dl>
<p>Returns: Tree object of parsed formula</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, formula: str) -&gt; Tree:
    &#34;&#34;&#34;
    Parses a given formula to a tree object
    Args:
        formula: Formula to parse

    Returns: Tree object of parsed formula

    &#34;&#34;&#34;
    try:
        self.reset_spatial_dict()  # every time you parse a new formula, reset the spatial dict
        return self._parser.parse(formula)
    except Exception as e:
        print(e)
        return None</code></pre>
</details>
</dd>
<dt id="spatial.logic.Spatial.parse_and_interpret"><code class="name flex">
<span>def <span class="ident">parse_and_interpret</span></span>(<span>self, formula: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses and interprets a given formula</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>formula</code></strong></dt>
<dd>Formula as string</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_and_interpret(self, formula: str):
    &#34;&#34;&#34;
    Parses and interprets a given formula
    Args:
        formula: Formula as string

    Returns:

    &#34;&#34;&#34;
    self.reset_spatial_dict()
    return self.interpret(self.parse(formula))</code></pre>
</details>
</dd>
<dt id="spatial.logic.Spatial.reset_spatial_dict"><code class="name flex">
<span>def <span class="ident">reset_spatial_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the spatial interpreter call history</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_spatial_dict(self):
    &#34;&#34;&#34;
    Resets the spatial interpreter call history
    &#34;&#34;&#34;
    self._tl_interpreter._spatial_dict = {}</code></pre>
</details>
</dd>
<dt id="spatial.logic.Spatial.save_to_file"><code class="name flex">
<span>def <span class="ident">save_to_file</span></span>(<span>self, file: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the state of the interpreter to the files system</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>The filename</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_to_file(self, file: str):
    &#34;&#34;&#34;
    Saves the state of the interpreter to the files system
    Args:
        file: The filename

    &#34;&#34;&#34;
    try:
        pickle.dump(self._spatial_interpreter, open(file, &#39;wb&#39;))
    except Exception as e:
        print(e)</code></pre>
</details>
</dd>
<dt id="spatial.logic.Spatial.update_variables"><code class="name flex">
<span>def <span class="ident">update_variables</span></span>(<span>self, vars: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the set of variables in the interpreter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vars</code></strong></dt>
<dd>The new set of variables</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_variables(self, vars: dict):
    &#34;&#34;&#34;
    Update the set of variables in the interpreter
    Args:
        vars: The new set of variables

    &#34;&#34;&#34;
    self._tl_interpreter.vars = vars</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spatial.logic.SpatialInterpreter"><code class="flex name class">
<span>class <span class="ident">SpatialInterpreter</span></span>
<span>(</span><span>spatial, quantitative: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpreter object for the temporal parts of Spatial. Delegates parsed tree to corresponding operations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpatialInterpreter(Interpreter):
    &#34;&#34;&#34;
    Interpreter object for the temporal parts of Spatial. Delegates parsed tree to corresponding operations.
    &#34;&#34;&#34;

    def __init__(self, spatial, quantitative: bool = False):
        self._quantitative = quantitative
        self._spatial_interpreter = spatial
        self._spatial_dict = {}
        self.vars = {}

    @property
    def quantitative(self) -&gt; bool:
        &#34;&#34;&#34;
        Bool whether this interpreter returns boolean or quantitative values

        Returns: True if quantitative

        &#34;&#34;&#34;
        return self._quantitative

    @quantitative.setter
    def quantitative(self, quantitative: bool):
        &#34;&#34;&#34;
        Bool whether this interpreter returns boolean or quantitative values
        Args:
            quantitative: Set a new bool

        &#34;&#34;&#34;
        self._quantitative = quantitative

    @property
    def vars(self) -&gt; dict:
        &#34;&#34;&#34;
        Dictionary of stored (name, variable) pairs
        Returns: dictionary

        &#34;&#34;&#34;
        return self._vars

    @vars.setter
    def vars(self, vars: dict):
        &#34;&#34;&#34;
        Sets the dictionary of stored (name, variable) pairs
        Args:
            vars: Dictionary

        &#34;&#34;&#34;
        if len(vars) &gt; 1:
            elements = list(vars.values())
            assert all([isinstance(k, ObjectInTime) for k in
                        elements]), &#39;&lt;SpatialInterpreter&gt;: only ObjectInTime currently supported!&#39;
        self._vars = vars

    def assign_var(self, name: str, value: ObjectInTime):
        &#34;&#34;&#34;
        Assigns a new variable to the interpreter
        Args:
            name: Name of the variable
            value: Value of the variables (ObjectInTime interface object or int/float)

        &#34;&#34;&#34;
        if isinstance(value, (int, float)):
            self._spatial_interpreter.assign_var(name, value)
        else:

            assert isinstance(value,
                              ObjectInTime), &#39;&lt;SpatialInterpreter&gt;: value must be of type &#39; \
                                             &#39;ObjectInTime or int/float! Got {}&#39;.format(
                value)
            assert isinstance(name, str), &#39;&lt;SpatialInterpreter&gt;: name must be of type string! Got {}&#39;.format(name)

            self.vars[name.lower()] = value
        return value

    def var(self, name: str) -&gt; ObjectInTime:
        &#34;&#34;&#34;
        Returns the variable corresponding to the provided name
        Args:
            name: Name of the variable

        Returns: spatial interface object of name

        &#34;&#34;&#34;
        try:
            return self.vars[name.lower()]
        except KeyError:
            raise Exception(&#34;Variable not found: %s&#34; % name)

    # translates the relative bounds of bounded temporal operators into the absolute time
    @staticmethod
    def relative_to_absolute_bounds(rel_lower, rel_upper, lower, upper):
        assert rel_lower &gt;= 0 and rel_upper &gt;= 0, \
            &#39;&lt;SpatialInterpreter&gt;: negative bounds in bounded temporal operators not allowed!&#39;
        assert rel_lower &lt;= rel_upper, \
            &#39;&lt;SpatialInterpreter&gt;: relative lower bound is higher than relative upper bound&#39;

        abs_lower = lower + rel_lower
        abs_upper = min(upper, lower + rel_upper)

        return abs_lower, abs_upper

    # hacky override of original function. provides necessary extra parameters for custom function wrapper
    def visit(self, tree, lower, upper):
        f = getattr(self, tree.data)
        wrapper = getattr(f, &#39;visit_wrapper&#39;, None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta, lower, upper)
        else:
            return f(tree)

    def temporal(self, tree, lower, upper):
        # temporal has only one child
        return self.visit(tree.children[0], lower, upper)

    def and_(self, tree, lower, upper):
        # and_ has two children
        left = self.visit(tree.children[0], lower, upper)
        right = self.visit(tree.children[1], lower, upper)
        return np.nanmin([left, right])

    def or_(self, tree, lower, upper):
        # or_ has two children
        left = self.visit(tree.children[0], lower, upper)
        right = self.visit(tree.children[1], lower, upper)
        return np.nanmax([left, right])

    def xor_(self, tree, lower, upper):
        # xor_ has two children
        left = self.visit(tree.children[0], lower, upper)
        right = self.visit(tree.children[1], lower, upper)
        # a XOR b = (a &amp; !b) | (!a &amp; b)
        a_notb = np.nanmin([left, -right])
        nota_b = np.nanmin([-left, right])
        return np.nanmax([a_notb, nota_b])

    def implies_(self, tree, lower, upper):
        # implies_ has two children
        left = self.visit(tree.children[0], lower, upper)
        right = self.visit(tree.children[1], lower, upper)
        return np.nanmax([-left, right])  # works because a -&gt; b == !a v b

    def not_(self, tree, lower, upper):
        # not_ has a single child
        return -self.visit(tree.children[0], lower, upper)

    def eventually(self, tree, lower, upper):
        results = []
        for i in range(lower, upper + 1):
            results.append(self.visit(tree.children[0], i, upper))
            # speedup in case the interpreter is run in boolean mode
            if not self.quantitative and results[-1] &gt;= 0:
                return 1.
        return np.nanmax(results)

    def eventually_bounded(self, tree, lower, upper):
        bound = tree.children[0]
        rel_bound_l = int(bound.children[0].children[0])
        rel_bound_u = int(bound.children[1].children[0])

        abs_bound_l, abs_bound_u = self.relative_to_absolute_bounds(rel_bound_l, rel_bound_u, lower, upper)
        # this happens when the relative lower bound references a point in time later than upper
        if abs_bound_l &gt; abs_bound_u:
            return np.nan

        # create a &#39;fake&#39; eventually tree and interpret it over new bounds
        eventually_tree = Tree(&#39;eventually&#39;, [tree.children[1]])
        return self.eventually(eventually_tree, abs_bound_l, abs_bound_u)

    def always(self, tree, lower, upper):
        # always has only one child
        results = []
        for i in range(lower, upper + 1):
            results.append(self.visit(tree.children[0], i, upper))
            # speedup in case the interpreter is run in boolean mode
            if not self.quantitative and results[-1] &lt; 0:
                return -1.
        return np.nanmin(results)

    def always_bounded(self, tree, lower, upper):
        bound = tree.children[0]
        rel_bound_l = int(bound.children[0].children[0])
        rel_bound_u = int(bound.children[1].children[0])

        abs_bound_l, abs_bound_u = self.relative_to_absolute_bounds(rel_bound_l, rel_bound_u, lower, upper)
        # this happens when the relative lower bound references a point in time later than upper
        if abs_bound_l &gt; abs_bound_u:
            return np.nan

        # create a &#39;fake&#39; always tree and interpret it over new bounds
        always_tree = Tree(&#39;always&#39;, [tree.children[1]])
        return self.always(always_tree, abs_bound_l, abs_bound_u)

    def next(self, tree, lower, upper):
        if lower + 1 &gt; upper:
            return np.nan

        # next always has only one child
        return self.visit(tree.children[0], lower + 1, upper)

    until_storage = dict()

    def until(self, tree, lower, upper):
        # final result
        result = -np.inf

        # store results of current tree evaluation in lookup table
        element = hash((tree.children[0], tree.children[1]))
        if element not in self.until_storage:
            self.until_storage[element] = {}
        # get dictionary of previous calls
        # stores calls of self.visit(tree.children[0], j, k). key is (i, k), value is result
        v2_dict = self.until_storage[element]

        for k in range(lower, upper + 1):
            v1 = self.visit(tree.children[1], k, upper)
            # this whole section is simply
            # v2 = min(self.visit(tree.children[0], j, k) for j in range(lower, k+1))
            v2 = np.inf
            for j in range(lower, k + 1):
                interval = (j, k)
                if interval not in v2_dict:
                    val = self.visit(tree.children[0], j, k)
                    v2_dict[interval] = val
                    if val &lt; v2:
                        v2 = val
                else:
                    val = v2_dict[interval]
                    if val &lt; v2:
                        v2 = val
            val = np.nanmin([v1, v2])
            if val &gt; result:
                result = val
        return result

    def until_bounded(self, tree, lower, upper):
        bound = tree.children[1]
        rel_bound_l = int(bound.children[0].children[0])
        rel_bound_u = int(bound.children[1].children[0])

        abs_bound_l, abs_bound_u = self.relative_to_absolute_bounds(rel_bound_l, rel_bound_u, lower, upper)
        # this happens when the relative lower bound references a point in time later than upper
        if abs_bound_l &gt; abs_bound_u:
            return np.nan

        # create a &#39;fake&#39; until tree and interpret it over new bounds
        until_tree = Tree(&#39;until&#39;, [tree.children[0], tree.children[2]])
        return self.always(until_tree, abs_bound_l, abs_bound_u)

    def spatial(self, tree, lower, upper):
        # check if this spatial formula has already been evaluated for this time point
        element = hash((tree, lower))  # compute hash once
        if element not in self._spatial_dict:
            # set global time for evaluation of formula
            self._spatial_interpreter.set_global_time(lower)
            val = self._spatial_interpreter.transform(tree)
            self._spatial_dict[element] = val
        return self._spatial_dict[element]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>lark.visitors.Interpreter</li>
<li>lark.visitors._Decoratable</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spatial.logic.SpatialInterpreter.until_storage"><code class="name">var <span class="ident">until_storage</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="spatial.logic.SpatialInterpreter.quantitative"><code class="name">var <span class="ident">quantitative</span> : bool</code></dt>
<dd>
<div class="desc"><p>Bool whether this interpreter returns boolean or quantitative values</p>
<p>Returns: True if quantitative</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def quantitative(self) -&gt; bool:
    &#34;&#34;&#34;
    Bool whether this interpreter returns boolean or quantitative values

    Returns: True if quantitative

    &#34;&#34;&#34;
    return self._quantitative</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.vars"><code class="name">var <span class="ident">vars</span> : dict</code></dt>
<dd>
<div class="desc"><p>Dictionary of stored (name, variable) pairs
Returns: dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vars(self) -&gt; dict:
    &#34;&#34;&#34;
    Dictionary of stored (name, variable) pairs
    Returns: dictionary

    &#34;&#34;&#34;
    return self._vars</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spatial.logic.SpatialInterpreter.always"><code class="name flex">
<span>def <span class="ident">always</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def always(self, tree, lower, upper):
    # always has only one child
    results = []
    for i in range(lower, upper + 1):
        results.append(self.visit(tree.children[0], i, upper))
        # speedup in case the interpreter is run in boolean mode
        if not self.quantitative and results[-1] &lt; 0:
            return -1.
    return np.nanmin(results)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.always_bounded"><code class="name flex">
<span>def <span class="ident">always_bounded</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def always_bounded(self, tree, lower, upper):
    bound = tree.children[0]
    rel_bound_l = int(bound.children[0].children[0])
    rel_bound_u = int(bound.children[1].children[0])

    abs_bound_l, abs_bound_u = self.relative_to_absolute_bounds(rel_bound_l, rel_bound_u, lower, upper)
    # this happens when the relative lower bound references a point in time later than upper
    if abs_bound_l &gt; abs_bound_u:
        return np.nan

    # create a &#39;fake&#39; always tree and interpret it over new bounds
    always_tree = Tree(&#39;always&#39;, [tree.children[1]])
    return self.always(always_tree, abs_bound_l, abs_bound_u)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.and_"><code class="name flex">
<span>def <span class="ident">and_</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def and_(self, tree, lower, upper):
    # and_ has two children
    left = self.visit(tree.children[0], lower, upper)
    right = self.visit(tree.children[1], lower, upper)
    return np.nanmin([left, right])</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.assign_var"><code class="name flex">
<span>def <span class="ident">assign_var</span></span>(<span>self, name: str, value: <a title="spatial.geometry.ObjectInTime" href="geometry.html#spatial.geometry.ObjectInTime">ObjectInTime</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Assigns a new variable to the interpreter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the variable</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Value of the variables (ObjectInTime interface object or int/float)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_var(self, name: str, value: ObjectInTime):
    &#34;&#34;&#34;
    Assigns a new variable to the interpreter
    Args:
        name: Name of the variable
        value: Value of the variables (ObjectInTime interface object or int/float)

    &#34;&#34;&#34;
    if isinstance(value, (int, float)):
        self._spatial_interpreter.assign_var(name, value)
    else:

        assert isinstance(value,
                          ObjectInTime), &#39;&lt;SpatialInterpreter&gt;: value must be of type &#39; \
                                         &#39;ObjectInTime or int/float! Got {}&#39;.format(
            value)
        assert isinstance(name, str), &#39;&lt;SpatialInterpreter&gt;: name must be of type string! Got {}&#39;.format(name)

        self.vars[name.lower()] = value
    return value</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.eventually"><code class="name flex">
<span>def <span class="ident">eventually</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eventually(self, tree, lower, upper):
    results = []
    for i in range(lower, upper + 1):
        results.append(self.visit(tree.children[0], i, upper))
        # speedup in case the interpreter is run in boolean mode
        if not self.quantitative and results[-1] &gt;= 0:
            return 1.
    return np.nanmax(results)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.eventually_bounded"><code class="name flex">
<span>def <span class="ident">eventually_bounded</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eventually_bounded(self, tree, lower, upper):
    bound = tree.children[0]
    rel_bound_l = int(bound.children[0].children[0])
    rel_bound_u = int(bound.children[1].children[0])

    abs_bound_l, abs_bound_u = self.relative_to_absolute_bounds(rel_bound_l, rel_bound_u, lower, upper)
    # this happens when the relative lower bound references a point in time later than upper
    if abs_bound_l &gt; abs_bound_u:
        return np.nan

    # create a &#39;fake&#39; eventually tree and interpret it over new bounds
    eventually_tree = Tree(&#39;eventually&#39;, [tree.children[1]])
    return self.eventually(eventually_tree, abs_bound_l, abs_bound_u)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.implies_"><code class="name flex">
<span>def <span class="ident">implies_</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def implies_(self, tree, lower, upper):
    # implies_ has two children
    left = self.visit(tree.children[0], lower, upper)
    right = self.visit(tree.children[1], lower, upper)
    return np.nanmax([-left, right])  # works because a -&gt; b == !a v b</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next(self, tree, lower, upper):
    if lower + 1 &gt; upper:
        return np.nan

    # next always has only one child
    return self.visit(tree.children[0], lower + 1, upper)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.not_"><code class="name flex">
<span>def <span class="ident">not_</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def not_(self, tree, lower, upper):
    # not_ has a single child
    return -self.visit(tree.children[0], lower, upper)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.or_"><code class="name flex">
<span>def <span class="ident">or_</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def or_(self, tree, lower, upper):
    # or_ has two children
    left = self.visit(tree.children[0], lower, upper)
    right = self.visit(tree.children[1], lower, upper)
    return np.nanmax([left, right])</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.relative_to_absolute_bounds"><code class="name flex">
<span>def <span class="ident">relative_to_absolute_bounds</span></span>(<span>rel_lower, rel_upper, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def relative_to_absolute_bounds(rel_lower, rel_upper, lower, upper):
    assert rel_lower &gt;= 0 and rel_upper &gt;= 0, \
        &#39;&lt;SpatialInterpreter&gt;: negative bounds in bounded temporal operators not allowed!&#39;
    assert rel_lower &lt;= rel_upper, \
        &#39;&lt;SpatialInterpreter&gt;: relative lower bound is higher than relative upper bound&#39;

    abs_lower = lower + rel_lower
    abs_upper = min(upper, lower + rel_upper)

    return abs_lower, abs_upper</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.spatial"><code class="name flex">
<span>def <span class="ident">spatial</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spatial(self, tree, lower, upper):
    # check if this spatial formula has already been evaluated for this time point
    element = hash((tree, lower))  # compute hash once
    if element not in self._spatial_dict:
        # set global time for evaluation of formula
        self._spatial_interpreter.set_global_time(lower)
        val = self._spatial_interpreter.transform(tree)
        self._spatial_dict[element] = val
    return self._spatial_dict[element]</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.temporal"><code class="name flex">
<span>def <span class="ident">temporal</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def temporal(self, tree, lower, upper):
    # temporal has only one child
    return self.visit(tree.children[0], lower, upper)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.until"><code class="name flex">
<span>def <span class="ident">until</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def until(self, tree, lower, upper):
    # final result
    result = -np.inf

    # store results of current tree evaluation in lookup table
    element = hash((tree.children[0], tree.children[1]))
    if element not in self.until_storage:
        self.until_storage[element] = {}
    # get dictionary of previous calls
    # stores calls of self.visit(tree.children[0], j, k). key is (i, k), value is result
    v2_dict = self.until_storage[element]

    for k in range(lower, upper + 1):
        v1 = self.visit(tree.children[1], k, upper)
        # this whole section is simply
        # v2 = min(self.visit(tree.children[0], j, k) for j in range(lower, k+1))
        v2 = np.inf
        for j in range(lower, k + 1):
            interval = (j, k)
            if interval not in v2_dict:
                val = self.visit(tree.children[0], j, k)
                v2_dict[interval] = val
                if val &lt; v2:
                    v2 = val
            else:
                val = v2_dict[interval]
                if val &lt; v2:
                    v2 = val
        val = np.nanmin([v1, v2])
        if val &gt; result:
            result = val
    return result</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.until_bounded"><code class="name flex">
<span>def <span class="ident">until_bounded</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def until_bounded(self, tree, lower, upper):
    bound = tree.children[1]
    rel_bound_l = int(bound.children[0].children[0])
    rel_bound_u = int(bound.children[1].children[0])

    abs_bound_l, abs_bound_u = self.relative_to_absolute_bounds(rel_bound_l, rel_bound_u, lower, upper)
    # this happens when the relative lower bound references a point in time later than upper
    if abs_bound_l &gt; abs_bound_u:
        return np.nan

    # create a &#39;fake&#39; until tree and interpret it over new bounds
    until_tree = Tree(&#39;until&#39;, [tree.children[0], tree.children[2]])
    return self.always(until_tree, abs_bound_l, abs_bound_u)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.var"><code class="name flex">
<span>def <span class="ident">var</span></span>(<span>self, name: str) ‑> <a title="spatial.geometry.ObjectInTime" href="geometry.html#spatial.geometry.ObjectInTime">ObjectInTime</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the variable corresponding to the provided name</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the variable</dd>
</dl>
<p>Returns: spatial interface object of name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def var(self, name: str) -&gt; ObjectInTime:
    &#34;&#34;&#34;
    Returns the variable corresponding to the provided name
    Args:
        name: Name of the variable

    Returns: spatial interface object of name

    &#34;&#34;&#34;
    try:
        return self.vars[name.lower()]
    except KeyError:
        raise Exception(&#34;Variable not found: %s&#34; % name)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, tree, lower, upper):
    f = getattr(self, tree.data)
    wrapper = getattr(f, &#39;visit_wrapper&#39;, None)
    if wrapper is not None:
        return f.visit_wrapper(f, tree.data, tree.children, tree.meta, lower, upper)
    else:
        return f(tree)</code></pre>
</details>
</dd>
<dt id="spatial.logic.SpatialInterpreter.xor_"><code class="name flex">
<span>def <span class="ident">xor_</span></span>(<span>self, tree, lower, upper)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xor_(self, tree, lower, upper):
    # xor_ has two children
    left = self.visit(tree.children[0], lower, upper)
    right = self.visit(tree.children[1], lower, upper)
    # a XOR b = (a &amp; !b) | (!a &amp; b)
    a_notb = np.nanmin([left, -right])
    nota_b = np.nanmin([-left, right])
    return np.nanmax([a_notb, nota_b])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spatial" href="index.html">spatial</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spatial.logic.SpatRelInterpreter" href="#spatial.logic.SpatRelInterpreter">SpatRelInterpreter</a></code></h4>
<ul class="two-column">
<li><code><a title="spatial.logic.SpatRelInterpreter.above_of" href="#spatial.logic.SpatRelInterpreter.above_of">above_of</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.and_" href="#spatial.logic.SpatRelInterpreter.and_">and_</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.assign_var" href="#spatial.logic.SpatRelInterpreter.assign_var">assign_var</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.below_of" href="#spatial.logic.SpatRelInterpreter.below_of">below_of</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.close_to" href="#spatial.logic.SpatRelInterpreter.close_to">close_to</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.closer_to" href="#spatial.logic.SpatRelInterpreter.closer_to">closer_to</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.comparison" href="#spatial.logic.SpatRelInterpreter.comparison">comparison</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.distance" href="#spatial.logic.SpatRelInterpreter.distance">distance</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.enclosed_in" href="#spatial.logic.SpatRelInterpreter.enclosed_in">enclosed_in</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.enlarge" href="#spatial.logic.SpatRelInterpreter.enlarge">enlarge</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.far_from" href="#spatial.logic.SpatRelInterpreter.far_from">far_from</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.implies_" href="#spatial.logic.SpatRelInterpreter.implies_">implies_</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.left_of" href="#spatial.logic.SpatRelInterpreter.left_of">left_of</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.moved" href="#spatial.logic.SpatRelInterpreter.moved">moved</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.not_" href="#spatial.logic.SpatRelInterpreter.not_">not_</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.number" href="#spatial.logic.SpatRelInterpreter.number">number</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.number_vars" href="#spatial.logic.SpatRelInterpreter.number_vars">number_vars</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.numeric_var" href="#spatial.logic.SpatRelInterpreter.numeric_var">numeric_var</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.operator" href="#spatial.logic.SpatRelInterpreter.operator">operator</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.or_" href="#spatial.logic.SpatRelInterpreter.or_">or_</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.overlap" href="#spatial.logic.SpatRelInterpreter.overlap">overlap</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.right_of" href="#spatial.logic.SpatRelInterpreter.right_of">right_of</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.set_global_time" href="#spatial.logic.SpatRelInterpreter.set_global_time">set_global_time</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.spatial" href="#spatial.logic.SpatRelInterpreter.spatial">spatial</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.touching" href="#spatial.logic.SpatRelInterpreter.touching">touching</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.var" href="#spatial.logic.SpatRelInterpreter.var">var</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.var_at" href="#spatial.logic.SpatRelInterpreter.var_at">var_at</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.vars" href="#spatial.logic.SpatRelInterpreter.vars">vars</a></code></li>
<li><code><a title="spatial.logic.SpatRelInterpreter.xor_" href="#spatial.logic.SpatRelInterpreter.xor_">xor_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spatial.logic.Spatial" href="#spatial.logic.Spatial">Spatial</a></code></h4>
<ul class="">
<li><code><a title="spatial.logic.Spatial.assign_variable" href="#spatial.logic.Spatial.assign_variable">assign_variable</a></code></li>
<li><code><a title="spatial.logic.Spatial.check_variables" href="#spatial.logic.Spatial.check_variables">check_variables</a></code></li>
<li><code><a title="spatial.logic.Spatial.determine_variables" href="#spatial.logic.Spatial.determine_variables">determine_variables</a></code></li>
<li><code><a title="spatial.logic.Spatial.from_file" href="#spatial.logic.Spatial.from_file">from_file</a></code></li>
<li><code><a title="spatial.logic.Spatial.interpret" href="#spatial.logic.Spatial.interpret">interpret</a></code></li>
<li><code><a title="spatial.logic.Spatial.load_formulas_from_file" href="#spatial.logic.Spatial.load_formulas_from_file">load_formulas_from_file</a></code></li>
<li><code><a title="spatial.logic.Spatial.min_time_of_formula" href="#spatial.logic.Spatial.min_time_of_formula">min_time_of_formula</a></code></li>
<li><code><a title="spatial.logic.Spatial.parse" href="#spatial.logic.Spatial.parse">parse</a></code></li>
<li><code><a title="spatial.logic.Spatial.parse_and_interpret" href="#spatial.logic.Spatial.parse_and_interpret">parse_and_interpret</a></code></li>
<li><code><a title="spatial.logic.Spatial.png_from_tree" href="#spatial.logic.Spatial.png_from_tree">png_from_tree</a></code></li>
<li><code><a title="spatial.logic.Spatial.quantitative" href="#spatial.logic.Spatial.quantitative">quantitative</a></code></li>
<li><code><a title="spatial.logic.Spatial.reset_spatial_dict" href="#spatial.logic.Spatial.reset_spatial_dict">reset_spatial_dict</a></code></li>
<li><code><a title="spatial.logic.Spatial.save_to_file" href="#spatial.logic.Spatial.save_to_file">save_to_file</a></code></li>
<li><code><a title="spatial.logic.Spatial.svg_from_tree" href="#spatial.logic.Spatial.svg_from_tree">svg_from_tree</a></code></li>
<li><code><a title="spatial.logic.Spatial.update_variables" href="#spatial.logic.Spatial.update_variables">update_variables</a></code></li>
<li><code><a title="spatial.logic.Spatial.write_formulas_to_file" href="#spatial.logic.Spatial.write_formulas_to_file">write_formulas_to_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spatial.logic.SpatialInterpreter" href="#spatial.logic.SpatialInterpreter">SpatialInterpreter</a></code></h4>
<ul class="">
<li><code><a title="spatial.logic.SpatialInterpreter.always" href="#spatial.logic.SpatialInterpreter.always">always</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.always_bounded" href="#spatial.logic.SpatialInterpreter.always_bounded">always_bounded</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.and_" href="#spatial.logic.SpatialInterpreter.and_">and_</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.assign_var" href="#spatial.logic.SpatialInterpreter.assign_var">assign_var</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.eventually" href="#spatial.logic.SpatialInterpreter.eventually">eventually</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.eventually_bounded" href="#spatial.logic.SpatialInterpreter.eventually_bounded">eventually_bounded</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.implies_" href="#spatial.logic.SpatialInterpreter.implies_">implies_</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.next" href="#spatial.logic.SpatialInterpreter.next">next</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.not_" href="#spatial.logic.SpatialInterpreter.not_">not_</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.or_" href="#spatial.logic.SpatialInterpreter.or_">or_</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.quantitative" href="#spatial.logic.SpatialInterpreter.quantitative">quantitative</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.relative_to_absolute_bounds" href="#spatial.logic.SpatialInterpreter.relative_to_absolute_bounds">relative_to_absolute_bounds</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.spatial" href="#spatial.logic.SpatialInterpreter.spatial">spatial</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.temporal" href="#spatial.logic.SpatialInterpreter.temporal">temporal</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.until" href="#spatial.logic.SpatialInterpreter.until">until</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.until_bounded" href="#spatial.logic.SpatialInterpreter.until_bounded">until_bounded</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.until_storage" href="#spatial.logic.SpatialInterpreter.until_storage">until_storage</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.var" href="#spatial.logic.SpatialInterpreter.var">var</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.vars" href="#spatial.logic.SpatialInterpreter.vars">vars</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.visit" href="#spatial.logic.SpatialInterpreter.visit">visit</a></code></li>
<li><code><a title="spatial.logic.SpatialInterpreter.xor_" href="#spatial.logic.SpatialInterpreter.xor_">xor_</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>